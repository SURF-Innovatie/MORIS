// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/SURF-Innovatie/MORIS/ent/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/SURF-Innovatie/MORIS/ent/descriptionchangedevent"
	"github.com/SURF-Innovatie/MORIS/ent/enddatechangedevent"
	"github.com/SURF-Innovatie/MORIS/ent/event"
	"github.com/SURF-Innovatie/MORIS/ent/notification"
	"github.com/SURF-Innovatie/MORIS/ent/organisation"
	"github.com/SURF-Innovatie/MORIS/ent/organisationchangedevent"
	"github.com/SURF-Innovatie/MORIS/ent/person"
	"github.com/SURF-Innovatie/MORIS/ent/personaddedevent"
	"github.com/SURF-Innovatie/MORIS/ent/personremovedevent"
	"github.com/SURF-Innovatie/MORIS/ent/product"
	"github.com/SURF-Innovatie/MORIS/ent/productaddedevent"
	"github.com/SURF-Innovatie/MORIS/ent/productremovedevent"
	"github.com/SURF-Innovatie/MORIS/ent/projectstartedevent"
	"github.com/SURF-Innovatie/MORIS/ent/startdatechangedevent"
	"github.com/SURF-Innovatie/MORIS/ent/titlechangedevent"
	"github.com/SURF-Innovatie/MORIS/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// DescriptionChangedEvent is the client for interacting with the DescriptionChangedEvent builders.
	DescriptionChangedEvent *DescriptionChangedEventClient
	// EndDateChangedEvent is the client for interacting with the EndDateChangedEvent builders.
	EndDateChangedEvent *EndDateChangedEventClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// Notification is the client for interacting with the Notification builders.
	Notification *NotificationClient
	// Organisation is the client for interacting with the Organisation builders.
	Organisation *OrganisationClient
	// OrganisationChangedEvent is the client for interacting with the OrganisationChangedEvent builders.
	OrganisationChangedEvent *OrganisationChangedEventClient
	// Person is the client for interacting with the Person builders.
	Person *PersonClient
	// PersonAddedEvent is the client for interacting with the PersonAddedEvent builders.
	PersonAddedEvent *PersonAddedEventClient
	// PersonRemovedEvent is the client for interacting with the PersonRemovedEvent builders.
	PersonRemovedEvent *PersonRemovedEventClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// ProductAddedEvent is the client for interacting with the ProductAddedEvent builders.
	ProductAddedEvent *ProductAddedEventClient
	// ProductRemovedEvent is the client for interacting with the ProductRemovedEvent builders.
	ProductRemovedEvent *ProductRemovedEventClient
	// ProjectStartedEvent is the client for interacting with the ProjectStartedEvent builders.
	ProjectStartedEvent *ProjectStartedEventClient
	// StartDateChangedEvent is the client for interacting with the StartDateChangedEvent builders.
	StartDateChangedEvent *StartDateChangedEventClient
	// TitleChangedEvent is the client for interacting with the TitleChangedEvent builders.
	TitleChangedEvent *TitleChangedEventClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.DescriptionChangedEvent = NewDescriptionChangedEventClient(c.config)
	c.EndDateChangedEvent = NewEndDateChangedEventClient(c.config)
	c.Event = NewEventClient(c.config)
	c.Notification = NewNotificationClient(c.config)
	c.Organisation = NewOrganisationClient(c.config)
	c.OrganisationChangedEvent = NewOrganisationChangedEventClient(c.config)
	c.Person = NewPersonClient(c.config)
	c.PersonAddedEvent = NewPersonAddedEventClient(c.config)
	c.PersonRemovedEvent = NewPersonRemovedEventClient(c.config)
	c.Product = NewProductClient(c.config)
	c.ProductAddedEvent = NewProductAddedEventClient(c.config)
	c.ProductRemovedEvent = NewProductRemovedEventClient(c.config)
	c.ProjectStartedEvent = NewProjectStartedEventClient(c.config)
	c.StartDateChangedEvent = NewStartDateChangedEventClient(c.config)
	c.TitleChangedEvent = NewTitleChangedEventClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                      ctx,
		config:                   cfg,
		DescriptionChangedEvent:  NewDescriptionChangedEventClient(cfg),
		EndDateChangedEvent:      NewEndDateChangedEventClient(cfg),
		Event:                    NewEventClient(cfg),
		Notification:             NewNotificationClient(cfg),
		Organisation:             NewOrganisationClient(cfg),
		OrganisationChangedEvent: NewOrganisationChangedEventClient(cfg),
		Person:                   NewPersonClient(cfg),
		PersonAddedEvent:         NewPersonAddedEventClient(cfg),
		PersonRemovedEvent:       NewPersonRemovedEventClient(cfg),
		Product:                  NewProductClient(cfg),
		ProductAddedEvent:        NewProductAddedEventClient(cfg),
		ProductRemovedEvent:      NewProductRemovedEventClient(cfg),
		ProjectStartedEvent:      NewProjectStartedEventClient(cfg),
		StartDateChangedEvent:    NewStartDateChangedEventClient(cfg),
		TitleChangedEvent:        NewTitleChangedEventClient(cfg),
		User:                     NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                      ctx,
		config:                   cfg,
		DescriptionChangedEvent:  NewDescriptionChangedEventClient(cfg),
		EndDateChangedEvent:      NewEndDateChangedEventClient(cfg),
		Event:                    NewEventClient(cfg),
		Notification:             NewNotificationClient(cfg),
		Organisation:             NewOrganisationClient(cfg),
		OrganisationChangedEvent: NewOrganisationChangedEventClient(cfg),
		Person:                   NewPersonClient(cfg),
		PersonAddedEvent:         NewPersonAddedEventClient(cfg),
		PersonRemovedEvent:       NewPersonRemovedEventClient(cfg),
		Product:                  NewProductClient(cfg),
		ProductAddedEvent:        NewProductAddedEventClient(cfg),
		ProductRemovedEvent:      NewProductRemovedEventClient(cfg),
		ProjectStartedEvent:      NewProjectStartedEventClient(cfg),
		StartDateChangedEvent:    NewStartDateChangedEventClient(cfg),
		TitleChangedEvent:        NewTitleChangedEventClient(cfg),
		User:                     NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		DescriptionChangedEvent.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.DescriptionChangedEvent, c.EndDateChangedEvent, c.Event, c.Notification,
		c.Organisation, c.OrganisationChangedEvent, c.Person, c.PersonAddedEvent,
		c.PersonRemovedEvent, c.Product, c.ProductAddedEvent, c.ProductRemovedEvent,
		c.ProjectStartedEvent, c.StartDateChangedEvent, c.TitleChangedEvent, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.DescriptionChangedEvent, c.EndDateChangedEvent, c.Event, c.Notification,
		c.Organisation, c.OrganisationChangedEvent, c.Person, c.PersonAddedEvent,
		c.PersonRemovedEvent, c.Product, c.ProductAddedEvent, c.ProductRemovedEvent,
		c.ProjectStartedEvent, c.StartDateChangedEvent, c.TitleChangedEvent, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *DescriptionChangedEventMutation:
		return c.DescriptionChangedEvent.mutate(ctx, m)
	case *EndDateChangedEventMutation:
		return c.EndDateChangedEvent.mutate(ctx, m)
	case *EventMutation:
		return c.Event.mutate(ctx, m)
	case *NotificationMutation:
		return c.Notification.mutate(ctx, m)
	case *OrganisationMutation:
		return c.Organisation.mutate(ctx, m)
	case *OrganisationChangedEventMutation:
		return c.OrganisationChangedEvent.mutate(ctx, m)
	case *PersonMutation:
		return c.Person.mutate(ctx, m)
	case *PersonAddedEventMutation:
		return c.PersonAddedEvent.mutate(ctx, m)
	case *PersonRemovedEventMutation:
		return c.PersonRemovedEvent.mutate(ctx, m)
	case *ProductMutation:
		return c.Product.mutate(ctx, m)
	case *ProductAddedEventMutation:
		return c.ProductAddedEvent.mutate(ctx, m)
	case *ProductRemovedEventMutation:
		return c.ProductRemovedEvent.mutate(ctx, m)
	case *ProjectStartedEventMutation:
		return c.ProjectStartedEvent.mutate(ctx, m)
	case *StartDateChangedEventMutation:
		return c.StartDateChangedEvent.mutate(ctx, m)
	case *TitleChangedEventMutation:
		return c.TitleChangedEvent.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// DescriptionChangedEventClient is a client for the DescriptionChangedEvent schema.
type DescriptionChangedEventClient struct {
	config
}

// NewDescriptionChangedEventClient returns a client for the DescriptionChangedEvent from the given config.
func NewDescriptionChangedEventClient(c config) *DescriptionChangedEventClient {
	return &DescriptionChangedEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `descriptionchangedevent.Hooks(f(g(h())))`.
func (c *DescriptionChangedEventClient) Use(hooks ...Hook) {
	c.hooks.DescriptionChangedEvent = append(c.hooks.DescriptionChangedEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `descriptionchangedevent.Intercept(f(g(h())))`.
func (c *DescriptionChangedEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.DescriptionChangedEvent = append(c.inters.DescriptionChangedEvent, interceptors...)
}

// Create returns a builder for creating a DescriptionChangedEvent entity.
func (c *DescriptionChangedEventClient) Create() *DescriptionChangedEventCreate {
	mutation := newDescriptionChangedEventMutation(c.config, OpCreate)
	return &DescriptionChangedEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DescriptionChangedEvent entities.
func (c *DescriptionChangedEventClient) CreateBulk(builders ...*DescriptionChangedEventCreate) *DescriptionChangedEventCreateBulk {
	return &DescriptionChangedEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DescriptionChangedEventClient) MapCreateBulk(slice any, setFunc func(*DescriptionChangedEventCreate, int)) *DescriptionChangedEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DescriptionChangedEventCreateBulk{err: fmt.Errorf("calling to DescriptionChangedEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DescriptionChangedEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DescriptionChangedEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DescriptionChangedEvent.
func (c *DescriptionChangedEventClient) Update() *DescriptionChangedEventUpdate {
	mutation := newDescriptionChangedEventMutation(c.config, OpUpdate)
	return &DescriptionChangedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DescriptionChangedEventClient) UpdateOne(_m *DescriptionChangedEvent) *DescriptionChangedEventUpdateOne {
	mutation := newDescriptionChangedEventMutation(c.config, OpUpdateOne, withDescriptionChangedEvent(_m))
	return &DescriptionChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DescriptionChangedEventClient) UpdateOneID(id uuid.UUID) *DescriptionChangedEventUpdateOne {
	mutation := newDescriptionChangedEventMutation(c.config, OpUpdateOne, withDescriptionChangedEventID(id))
	return &DescriptionChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DescriptionChangedEvent.
func (c *DescriptionChangedEventClient) Delete() *DescriptionChangedEventDelete {
	mutation := newDescriptionChangedEventMutation(c.config, OpDelete)
	return &DescriptionChangedEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DescriptionChangedEventClient) DeleteOne(_m *DescriptionChangedEvent) *DescriptionChangedEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DescriptionChangedEventClient) DeleteOneID(id uuid.UUID) *DescriptionChangedEventDeleteOne {
	builder := c.Delete().Where(descriptionchangedevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DescriptionChangedEventDeleteOne{builder}
}

// Query returns a query builder for DescriptionChangedEvent.
func (c *DescriptionChangedEventClient) Query() *DescriptionChangedEventQuery {
	return &DescriptionChangedEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDescriptionChangedEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a DescriptionChangedEvent entity by its id.
func (c *DescriptionChangedEventClient) Get(ctx context.Context, id uuid.UUID) (*DescriptionChangedEvent, error) {
	return c.Query().Where(descriptionchangedevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DescriptionChangedEventClient) GetX(ctx context.Context, id uuid.UUID) *DescriptionChangedEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a DescriptionChangedEvent.
func (c *DescriptionChangedEventClient) QueryEvent(_m *DescriptionChangedEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(descriptionchangedevent.Table, descriptionchangedevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, descriptionchangedevent.EventTable, descriptionchangedevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DescriptionChangedEventClient) Hooks() []Hook {
	return c.hooks.DescriptionChangedEvent
}

// Interceptors returns the client interceptors.
func (c *DescriptionChangedEventClient) Interceptors() []Interceptor {
	return c.inters.DescriptionChangedEvent
}

func (c *DescriptionChangedEventClient) mutate(ctx context.Context, m *DescriptionChangedEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DescriptionChangedEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DescriptionChangedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DescriptionChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DescriptionChangedEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DescriptionChangedEvent mutation op: %q", m.Op())
	}
}

// EndDateChangedEventClient is a client for the EndDateChangedEvent schema.
type EndDateChangedEventClient struct {
	config
}

// NewEndDateChangedEventClient returns a client for the EndDateChangedEvent from the given config.
func NewEndDateChangedEventClient(c config) *EndDateChangedEventClient {
	return &EndDateChangedEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `enddatechangedevent.Hooks(f(g(h())))`.
func (c *EndDateChangedEventClient) Use(hooks ...Hook) {
	c.hooks.EndDateChangedEvent = append(c.hooks.EndDateChangedEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `enddatechangedevent.Intercept(f(g(h())))`.
func (c *EndDateChangedEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.EndDateChangedEvent = append(c.inters.EndDateChangedEvent, interceptors...)
}

// Create returns a builder for creating a EndDateChangedEvent entity.
func (c *EndDateChangedEventClient) Create() *EndDateChangedEventCreate {
	mutation := newEndDateChangedEventMutation(c.config, OpCreate)
	return &EndDateChangedEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EndDateChangedEvent entities.
func (c *EndDateChangedEventClient) CreateBulk(builders ...*EndDateChangedEventCreate) *EndDateChangedEventCreateBulk {
	return &EndDateChangedEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EndDateChangedEventClient) MapCreateBulk(slice any, setFunc func(*EndDateChangedEventCreate, int)) *EndDateChangedEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EndDateChangedEventCreateBulk{err: fmt.Errorf("calling to EndDateChangedEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EndDateChangedEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EndDateChangedEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EndDateChangedEvent.
func (c *EndDateChangedEventClient) Update() *EndDateChangedEventUpdate {
	mutation := newEndDateChangedEventMutation(c.config, OpUpdate)
	return &EndDateChangedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EndDateChangedEventClient) UpdateOne(_m *EndDateChangedEvent) *EndDateChangedEventUpdateOne {
	mutation := newEndDateChangedEventMutation(c.config, OpUpdateOne, withEndDateChangedEvent(_m))
	return &EndDateChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EndDateChangedEventClient) UpdateOneID(id uuid.UUID) *EndDateChangedEventUpdateOne {
	mutation := newEndDateChangedEventMutation(c.config, OpUpdateOne, withEndDateChangedEventID(id))
	return &EndDateChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EndDateChangedEvent.
func (c *EndDateChangedEventClient) Delete() *EndDateChangedEventDelete {
	mutation := newEndDateChangedEventMutation(c.config, OpDelete)
	return &EndDateChangedEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EndDateChangedEventClient) DeleteOne(_m *EndDateChangedEvent) *EndDateChangedEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EndDateChangedEventClient) DeleteOneID(id uuid.UUID) *EndDateChangedEventDeleteOne {
	builder := c.Delete().Where(enddatechangedevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EndDateChangedEventDeleteOne{builder}
}

// Query returns a query builder for EndDateChangedEvent.
func (c *EndDateChangedEventClient) Query() *EndDateChangedEventQuery {
	return &EndDateChangedEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEndDateChangedEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a EndDateChangedEvent entity by its id.
func (c *EndDateChangedEventClient) Get(ctx context.Context, id uuid.UUID) (*EndDateChangedEvent, error) {
	return c.Query().Where(enddatechangedevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EndDateChangedEventClient) GetX(ctx context.Context, id uuid.UUID) *EndDateChangedEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a EndDateChangedEvent.
func (c *EndDateChangedEventClient) QueryEvent(_m *EndDateChangedEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(enddatechangedevent.Table, enddatechangedevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, enddatechangedevent.EventTable, enddatechangedevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EndDateChangedEventClient) Hooks() []Hook {
	return c.hooks.EndDateChangedEvent
}

// Interceptors returns the client interceptors.
func (c *EndDateChangedEventClient) Interceptors() []Interceptor {
	return c.inters.EndDateChangedEvent
}

func (c *EndDateChangedEventClient) mutate(ctx context.Context, m *EndDateChangedEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EndDateChangedEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EndDateChangedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EndDateChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EndDateChangedEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EndDateChangedEvent mutation op: %q", m.Op())
	}
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event.Intercept(f(g(h())))`.
func (c *EventClient) Intercept(interceptors ...Interceptor) {
	c.inters.Event = append(c.inters.Event, interceptors...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventClient) MapCreateBulk(slice any, setFunc func(*EventCreate, int)) *EventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventCreateBulk{err: fmt.Errorf("calling to EventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(_m *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(_m))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id uuid.UUID) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(_m *Event) *EventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id uuid.UUID) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id uuid.UUID) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id uuid.UUID) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProjectStarted queries the project_started edge of a Event.
func (c *EventClient) QueryProjectStarted(_m *Event) *ProjectStartedEventQuery {
	query := (&ProjectStartedEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(projectstartedevent.Table, projectstartedevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.ProjectStartedTable, event.ProjectStartedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTitleChanged queries the title_changed edge of a Event.
func (c *EventClient) QueryTitleChanged(_m *Event) *TitleChangedEventQuery {
	query := (&TitleChangedEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(titlechangedevent.Table, titlechangedevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.TitleChangedTable, event.TitleChangedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDescriptionChanged queries the description_changed edge of a Event.
func (c *EventClient) QueryDescriptionChanged(_m *Event) *DescriptionChangedEventQuery {
	query := (&DescriptionChangedEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(descriptionchangedevent.Table, descriptionchangedevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.DescriptionChangedTable, event.DescriptionChangedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStartDateChanged queries the start_date_changed edge of a Event.
func (c *EventClient) QueryStartDateChanged(_m *Event) *StartDateChangedEventQuery {
	query := (&StartDateChangedEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(startdatechangedevent.Table, startdatechangedevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.StartDateChangedTable, event.StartDateChangedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEndDateChanged queries the end_date_changed edge of a Event.
func (c *EventClient) QueryEndDateChanged(_m *Event) *EndDateChangedEventQuery {
	query := (&EndDateChangedEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(enddatechangedevent.Table, enddatechangedevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.EndDateChangedTable, event.EndDateChangedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganisationChanged queries the organisation_changed edge of a Event.
func (c *EventClient) QueryOrganisationChanged(_m *Event) *OrganisationChangedEventQuery {
	query := (&OrganisationChangedEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(organisationchangedevent.Table, organisationchangedevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.OrganisationChangedTable, event.OrganisationChangedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonAdded queries the person_added edge of a Event.
func (c *EventClient) QueryPersonAdded(_m *Event) *PersonAddedEventQuery {
	query := (&PersonAddedEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(personaddedevent.Table, personaddedevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.PersonAddedTable, event.PersonAddedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonRemoved queries the person_removed edge of a Event.
func (c *EventClient) QueryPersonRemoved(_m *Event) *PersonRemovedEventQuery {
	query := (&PersonRemovedEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(personremovedevent.Table, personremovedevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.PersonRemovedTable, event.PersonRemovedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductAdded queries the product_added edge of a Event.
func (c *EventClient) QueryProductAdded(_m *Event) *ProductAddedEventQuery {
	query := (&ProductAddedEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(productaddedevent.Table, productaddedevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.ProductAddedTable, event.ProductAddedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductRemoved queries the product_removed edge of a Event.
func (c *EventClient) QueryProductRemoved(_m *Event) *ProductRemovedEventQuery {
	query := (&ProductRemovedEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(productremovedevent.Table, productremovedevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.ProductRemovedTable, event.ProductRemovedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	return c.hooks.Event
}

// Interceptors returns the client interceptors.
func (c *EventClient) Interceptors() []Interceptor {
	return c.inters.Event
}

func (c *EventClient) mutate(ctx context.Context, m *EventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Event mutation op: %q", m.Op())
	}
}

// NotificationClient is a client for the Notification schema.
type NotificationClient struct {
	config
}

// NewNotificationClient returns a client for the Notification from the given config.
func NewNotificationClient(c config) *NotificationClient {
	return &NotificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notification.Hooks(f(g(h())))`.
func (c *NotificationClient) Use(hooks ...Hook) {
	c.hooks.Notification = append(c.hooks.Notification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notification.Intercept(f(g(h())))`.
func (c *NotificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Notification = append(c.inters.Notification, interceptors...)
}

// Create returns a builder for creating a Notification entity.
func (c *NotificationClient) Create() *NotificationCreate {
	mutation := newNotificationMutation(c.config, OpCreate)
	return &NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Notification entities.
func (c *NotificationClient) CreateBulk(builders ...*NotificationCreate) *NotificationCreateBulk {
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationClient) MapCreateBulk(slice any, setFunc func(*NotificationCreate, int)) *NotificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationCreateBulk{err: fmt.Errorf("calling to NotificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Notification.
func (c *NotificationClient) Update() *NotificationUpdate {
	mutation := newNotificationMutation(c.config, OpUpdate)
	return &NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationClient) UpdateOne(_m *Notification) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotification(_m))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationClient) UpdateOneID(id uuid.UUID) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotificationID(id))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Notification.
func (c *NotificationClient) Delete() *NotificationDelete {
	mutation := newNotificationMutation(c.config, OpDelete)
	return &NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationClient) DeleteOne(_m *Notification) *NotificationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationClient) DeleteOneID(id uuid.UUID) *NotificationDeleteOne {
	builder := c.Delete().Where(notification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationDeleteOne{builder}
}

// Query returns a query builder for Notification.
func (c *NotificationClient) Query() *NotificationQuery {
	return &NotificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotification},
		inters: c.Interceptors(),
	}
}

// Get returns a Notification entity by its id.
func (c *NotificationClient) Get(ctx context.Context, id uuid.UUID) (*Notification, error) {
	return c.Query().Where(notification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationClient) GetX(ctx context.Context, id uuid.UUID) *Notification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Notification.
func (c *NotificationClient) QueryUser(_m *Notification) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, notification.UserTable, notification.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Notification.
func (c *NotificationClient) QueryEvent(_m *Notification) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, notification.EventTable, notification.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationClient) Hooks() []Hook {
	return c.hooks.Notification
}

// Interceptors returns the client interceptors.
func (c *NotificationClient) Interceptors() []Interceptor {
	return c.inters.Notification
}

func (c *NotificationClient) mutate(ctx context.Context, m *NotificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Notification mutation op: %q", m.Op())
	}
}

// OrganisationClient is a client for the Organisation schema.
type OrganisationClient struct {
	config
}

// NewOrganisationClient returns a client for the Organisation from the given config.
func NewOrganisationClient(c config) *OrganisationClient {
	return &OrganisationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organisation.Hooks(f(g(h())))`.
func (c *OrganisationClient) Use(hooks ...Hook) {
	c.hooks.Organisation = append(c.hooks.Organisation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organisation.Intercept(f(g(h())))`.
func (c *OrganisationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organisation = append(c.inters.Organisation, interceptors...)
}

// Create returns a builder for creating a Organisation entity.
func (c *OrganisationClient) Create() *OrganisationCreate {
	mutation := newOrganisationMutation(c.config, OpCreate)
	return &OrganisationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organisation entities.
func (c *OrganisationClient) CreateBulk(builders ...*OrganisationCreate) *OrganisationCreateBulk {
	return &OrganisationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganisationClient) MapCreateBulk(slice any, setFunc func(*OrganisationCreate, int)) *OrganisationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganisationCreateBulk{err: fmt.Errorf("calling to OrganisationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganisationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganisationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organisation.
func (c *OrganisationClient) Update() *OrganisationUpdate {
	mutation := newOrganisationMutation(c.config, OpUpdate)
	return &OrganisationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganisationClient) UpdateOne(_m *Organisation) *OrganisationUpdateOne {
	mutation := newOrganisationMutation(c.config, OpUpdateOne, withOrganisation(_m))
	return &OrganisationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganisationClient) UpdateOneID(id uuid.UUID) *OrganisationUpdateOne {
	mutation := newOrganisationMutation(c.config, OpUpdateOne, withOrganisationID(id))
	return &OrganisationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organisation.
func (c *OrganisationClient) Delete() *OrganisationDelete {
	mutation := newOrganisationMutation(c.config, OpDelete)
	return &OrganisationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganisationClient) DeleteOne(_m *Organisation) *OrganisationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganisationClient) DeleteOneID(id uuid.UUID) *OrganisationDeleteOne {
	builder := c.Delete().Where(organisation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganisationDeleteOne{builder}
}

// Query returns a query builder for Organisation.
func (c *OrganisationClient) Query() *OrganisationQuery {
	return &OrganisationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganisation},
		inters: c.Interceptors(),
	}
}

// Get returns a Organisation entity by its id.
func (c *OrganisationClient) Get(ctx context.Context, id uuid.UUID) (*Organisation, error) {
	return c.Query().Where(organisation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganisationClient) GetX(ctx context.Context, id uuid.UUID) *Organisation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrganisationClient) Hooks() []Hook {
	return c.hooks.Organisation
}

// Interceptors returns the client interceptors.
func (c *OrganisationClient) Interceptors() []Interceptor {
	return c.inters.Organisation
}

func (c *OrganisationClient) mutate(ctx context.Context, m *OrganisationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganisationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganisationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganisationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganisationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Organisation mutation op: %q", m.Op())
	}
}

// OrganisationChangedEventClient is a client for the OrganisationChangedEvent schema.
type OrganisationChangedEventClient struct {
	config
}

// NewOrganisationChangedEventClient returns a client for the OrganisationChangedEvent from the given config.
func NewOrganisationChangedEventClient(c config) *OrganisationChangedEventClient {
	return &OrganisationChangedEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organisationchangedevent.Hooks(f(g(h())))`.
func (c *OrganisationChangedEventClient) Use(hooks ...Hook) {
	c.hooks.OrganisationChangedEvent = append(c.hooks.OrganisationChangedEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organisationchangedevent.Intercept(f(g(h())))`.
func (c *OrganisationChangedEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganisationChangedEvent = append(c.inters.OrganisationChangedEvent, interceptors...)
}

// Create returns a builder for creating a OrganisationChangedEvent entity.
func (c *OrganisationChangedEventClient) Create() *OrganisationChangedEventCreate {
	mutation := newOrganisationChangedEventMutation(c.config, OpCreate)
	return &OrganisationChangedEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganisationChangedEvent entities.
func (c *OrganisationChangedEventClient) CreateBulk(builders ...*OrganisationChangedEventCreate) *OrganisationChangedEventCreateBulk {
	return &OrganisationChangedEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganisationChangedEventClient) MapCreateBulk(slice any, setFunc func(*OrganisationChangedEventCreate, int)) *OrganisationChangedEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganisationChangedEventCreateBulk{err: fmt.Errorf("calling to OrganisationChangedEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganisationChangedEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganisationChangedEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganisationChangedEvent.
func (c *OrganisationChangedEventClient) Update() *OrganisationChangedEventUpdate {
	mutation := newOrganisationChangedEventMutation(c.config, OpUpdate)
	return &OrganisationChangedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganisationChangedEventClient) UpdateOne(_m *OrganisationChangedEvent) *OrganisationChangedEventUpdateOne {
	mutation := newOrganisationChangedEventMutation(c.config, OpUpdateOne, withOrganisationChangedEvent(_m))
	return &OrganisationChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganisationChangedEventClient) UpdateOneID(id uuid.UUID) *OrganisationChangedEventUpdateOne {
	mutation := newOrganisationChangedEventMutation(c.config, OpUpdateOne, withOrganisationChangedEventID(id))
	return &OrganisationChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganisationChangedEvent.
func (c *OrganisationChangedEventClient) Delete() *OrganisationChangedEventDelete {
	mutation := newOrganisationChangedEventMutation(c.config, OpDelete)
	return &OrganisationChangedEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganisationChangedEventClient) DeleteOne(_m *OrganisationChangedEvent) *OrganisationChangedEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganisationChangedEventClient) DeleteOneID(id uuid.UUID) *OrganisationChangedEventDeleteOne {
	builder := c.Delete().Where(organisationchangedevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganisationChangedEventDeleteOne{builder}
}

// Query returns a query builder for OrganisationChangedEvent.
func (c *OrganisationChangedEventClient) Query() *OrganisationChangedEventQuery {
	return &OrganisationChangedEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganisationChangedEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganisationChangedEvent entity by its id.
func (c *OrganisationChangedEventClient) Get(ctx context.Context, id uuid.UUID) (*OrganisationChangedEvent, error) {
	return c.Query().Where(organisationchangedevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganisationChangedEventClient) GetX(ctx context.Context, id uuid.UUID) *OrganisationChangedEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a OrganisationChangedEvent.
func (c *OrganisationChangedEventClient) QueryEvent(_m *OrganisationChangedEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organisationchangedevent.Table, organisationchangedevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, organisationchangedevent.EventTable, organisationchangedevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganisationChangedEventClient) Hooks() []Hook {
	return c.hooks.OrganisationChangedEvent
}

// Interceptors returns the client interceptors.
func (c *OrganisationChangedEventClient) Interceptors() []Interceptor {
	return c.inters.OrganisationChangedEvent
}

func (c *OrganisationChangedEventClient) mutate(ctx context.Context, m *OrganisationChangedEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganisationChangedEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganisationChangedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganisationChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganisationChangedEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrganisationChangedEvent mutation op: %q", m.Op())
	}
}

// PersonClient is a client for the Person schema.
type PersonClient struct {
	config
}

// NewPersonClient returns a client for the Person from the given config.
func NewPersonClient(c config) *PersonClient {
	return &PersonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `person.Hooks(f(g(h())))`.
func (c *PersonClient) Use(hooks ...Hook) {
	c.hooks.Person = append(c.hooks.Person, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `person.Intercept(f(g(h())))`.
func (c *PersonClient) Intercept(interceptors ...Interceptor) {
	c.inters.Person = append(c.inters.Person, interceptors...)
}

// Create returns a builder for creating a Person entity.
func (c *PersonClient) Create() *PersonCreate {
	mutation := newPersonMutation(c.config, OpCreate)
	return &PersonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Person entities.
func (c *PersonClient) CreateBulk(builders ...*PersonCreate) *PersonCreateBulk {
	return &PersonCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PersonClient) MapCreateBulk(slice any, setFunc func(*PersonCreate, int)) *PersonCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PersonCreateBulk{err: fmt.Errorf("calling to PersonClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PersonCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PersonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Person.
func (c *PersonClient) Update() *PersonUpdate {
	mutation := newPersonMutation(c.config, OpUpdate)
	return &PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonClient) UpdateOne(_m *Person) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPerson(_m))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonClient) UpdateOneID(id uuid.UUID) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPersonID(id))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Person.
func (c *PersonClient) Delete() *PersonDelete {
	mutation := newPersonMutation(c.config, OpDelete)
	return &PersonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonClient) DeleteOne(_m *Person) *PersonDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonClient) DeleteOneID(id uuid.UUID) *PersonDeleteOne {
	builder := c.Delete().Where(person.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonDeleteOne{builder}
}

// Query returns a query builder for Person.
func (c *PersonClient) Query() *PersonQuery {
	return &PersonQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePerson},
		inters: c.Interceptors(),
	}
}

// Get returns a Person entity by its id.
func (c *PersonClient) Get(ctx context.Context, id uuid.UUID) (*Person, error) {
	return c.Query().Where(person.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonClient) GetX(ctx context.Context, id uuid.UUID) *Person {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a Person.
func (c *PersonClient) QueryProducts(_m *Person) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(person.Table, person.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, person.ProductsTable, person.ProductsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonClient) Hooks() []Hook {
	return c.hooks.Person
}

// Interceptors returns the client interceptors.
func (c *PersonClient) Interceptors() []Interceptor {
	return c.inters.Person
}

func (c *PersonClient) mutate(ctx context.Context, m *PersonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Person mutation op: %q", m.Op())
	}
}

// PersonAddedEventClient is a client for the PersonAddedEvent schema.
type PersonAddedEventClient struct {
	config
}

// NewPersonAddedEventClient returns a client for the PersonAddedEvent from the given config.
func NewPersonAddedEventClient(c config) *PersonAddedEventClient {
	return &PersonAddedEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `personaddedevent.Hooks(f(g(h())))`.
func (c *PersonAddedEventClient) Use(hooks ...Hook) {
	c.hooks.PersonAddedEvent = append(c.hooks.PersonAddedEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `personaddedevent.Intercept(f(g(h())))`.
func (c *PersonAddedEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.PersonAddedEvent = append(c.inters.PersonAddedEvent, interceptors...)
}

// Create returns a builder for creating a PersonAddedEvent entity.
func (c *PersonAddedEventClient) Create() *PersonAddedEventCreate {
	mutation := newPersonAddedEventMutation(c.config, OpCreate)
	return &PersonAddedEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PersonAddedEvent entities.
func (c *PersonAddedEventClient) CreateBulk(builders ...*PersonAddedEventCreate) *PersonAddedEventCreateBulk {
	return &PersonAddedEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PersonAddedEventClient) MapCreateBulk(slice any, setFunc func(*PersonAddedEventCreate, int)) *PersonAddedEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PersonAddedEventCreateBulk{err: fmt.Errorf("calling to PersonAddedEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PersonAddedEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PersonAddedEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PersonAddedEvent.
func (c *PersonAddedEventClient) Update() *PersonAddedEventUpdate {
	mutation := newPersonAddedEventMutation(c.config, OpUpdate)
	return &PersonAddedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonAddedEventClient) UpdateOne(_m *PersonAddedEvent) *PersonAddedEventUpdateOne {
	mutation := newPersonAddedEventMutation(c.config, OpUpdateOne, withPersonAddedEvent(_m))
	return &PersonAddedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonAddedEventClient) UpdateOneID(id int) *PersonAddedEventUpdateOne {
	mutation := newPersonAddedEventMutation(c.config, OpUpdateOne, withPersonAddedEventID(id))
	return &PersonAddedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PersonAddedEvent.
func (c *PersonAddedEventClient) Delete() *PersonAddedEventDelete {
	mutation := newPersonAddedEventMutation(c.config, OpDelete)
	return &PersonAddedEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonAddedEventClient) DeleteOne(_m *PersonAddedEvent) *PersonAddedEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonAddedEventClient) DeleteOneID(id int) *PersonAddedEventDeleteOne {
	builder := c.Delete().Where(personaddedevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonAddedEventDeleteOne{builder}
}

// Query returns a query builder for PersonAddedEvent.
func (c *PersonAddedEventClient) Query() *PersonAddedEventQuery {
	return &PersonAddedEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePersonAddedEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a PersonAddedEvent entity by its id.
func (c *PersonAddedEventClient) Get(ctx context.Context, id int) (*PersonAddedEvent, error) {
	return c.Query().Where(personaddedevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonAddedEventClient) GetX(ctx context.Context, id int) *PersonAddedEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a PersonAddedEvent.
func (c *PersonAddedEventClient) QueryEvent(_m *PersonAddedEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personaddedevent.Table, personaddedevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, personaddedevent.EventTable, personaddedevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonAddedEventClient) Hooks() []Hook {
	return c.hooks.PersonAddedEvent
}

// Interceptors returns the client interceptors.
func (c *PersonAddedEventClient) Interceptors() []Interceptor {
	return c.inters.PersonAddedEvent
}

func (c *PersonAddedEventClient) mutate(ctx context.Context, m *PersonAddedEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonAddedEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonAddedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonAddedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonAddedEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PersonAddedEvent mutation op: %q", m.Op())
	}
}

// PersonRemovedEventClient is a client for the PersonRemovedEvent schema.
type PersonRemovedEventClient struct {
	config
}

// NewPersonRemovedEventClient returns a client for the PersonRemovedEvent from the given config.
func NewPersonRemovedEventClient(c config) *PersonRemovedEventClient {
	return &PersonRemovedEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `personremovedevent.Hooks(f(g(h())))`.
func (c *PersonRemovedEventClient) Use(hooks ...Hook) {
	c.hooks.PersonRemovedEvent = append(c.hooks.PersonRemovedEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `personremovedevent.Intercept(f(g(h())))`.
func (c *PersonRemovedEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.PersonRemovedEvent = append(c.inters.PersonRemovedEvent, interceptors...)
}

// Create returns a builder for creating a PersonRemovedEvent entity.
func (c *PersonRemovedEventClient) Create() *PersonRemovedEventCreate {
	mutation := newPersonRemovedEventMutation(c.config, OpCreate)
	return &PersonRemovedEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PersonRemovedEvent entities.
func (c *PersonRemovedEventClient) CreateBulk(builders ...*PersonRemovedEventCreate) *PersonRemovedEventCreateBulk {
	return &PersonRemovedEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PersonRemovedEventClient) MapCreateBulk(slice any, setFunc func(*PersonRemovedEventCreate, int)) *PersonRemovedEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PersonRemovedEventCreateBulk{err: fmt.Errorf("calling to PersonRemovedEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PersonRemovedEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PersonRemovedEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PersonRemovedEvent.
func (c *PersonRemovedEventClient) Update() *PersonRemovedEventUpdate {
	mutation := newPersonRemovedEventMutation(c.config, OpUpdate)
	return &PersonRemovedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonRemovedEventClient) UpdateOne(_m *PersonRemovedEvent) *PersonRemovedEventUpdateOne {
	mutation := newPersonRemovedEventMutation(c.config, OpUpdateOne, withPersonRemovedEvent(_m))
	return &PersonRemovedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonRemovedEventClient) UpdateOneID(id int) *PersonRemovedEventUpdateOne {
	mutation := newPersonRemovedEventMutation(c.config, OpUpdateOne, withPersonRemovedEventID(id))
	return &PersonRemovedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PersonRemovedEvent.
func (c *PersonRemovedEventClient) Delete() *PersonRemovedEventDelete {
	mutation := newPersonRemovedEventMutation(c.config, OpDelete)
	return &PersonRemovedEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonRemovedEventClient) DeleteOne(_m *PersonRemovedEvent) *PersonRemovedEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonRemovedEventClient) DeleteOneID(id int) *PersonRemovedEventDeleteOne {
	builder := c.Delete().Where(personremovedevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonRemovedEventDeleteOne{builder}
}

// Query returns a query builder for PersonRemovedEvent.
func (c *PersonRemovedEventClient) Query() *PersonRemovedEventQuery {
	return &PersonRemovedEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePersonRemovedEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a PersonRemovedEvent entity by its id.
func (c *PersonRemovedEventClient) Get(ctx context.Context, id int) (*PersonRemovedEvent, error) {
	return c.Query().Where(personremovedevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonRemovedEventClient) GetX(ctx context.Context, id int) *PersonRemovedEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a PersonRemovedEvent.
func (c *PersonRemovedEventClient) QueryEvent(_m *PersonRemovedEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(personremovedevent.Table, personremovedevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, personremovedevent.EventTable, personremovedevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PersonRemovedEventClient) Hooks() []Hook {
	return c.hooks.PersonRemovedEvent
}

// Interceptors returns the client interceptors.
func (c *PersonRemovedEventClient) Interceptors() []Interceptor {
	return c.inters.PersonRemovedEvent
}

func (c *PersonRemovedEventClient) mutate(ctx context.Context, m *PersonRemovedEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonRemovedEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonRemovedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonRemovedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonRemovedEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PersonRemovedEvent mutation op: %q", m.Op())
	}
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `product.Intercept(f(g(h())))`.
func (c *ProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.Product = append(c.inters.Product, interceptors...)
}

// Create returns a builder for creating a Product entity.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Product entities.
func (c *ProductClient) CreateBulk(builders ...*ProductCreate) *ProductCreateBulk {
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductClient) MapCreateBulk(slice any, setFunc func(*ProductCreate, int)) *ProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductCreateBulk{err: fmt.Errorf("calling to ProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(_m *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(_m))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id uuid.UUID) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductClient) DeleteOne(_m *Product) *ProductDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductClient) DeleteOneID(id uuid.UUID) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Query returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id uuid.UUID) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id uuid.UUID) *Product {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthor queries the author edge of a Product.
func (c *ProductClient) QueryAuthor(_m *Product) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, product.AuthorTable, product.AuthorPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	return c.hooks.Product
}

// Interceptors returns the client interceptors.
func (c *ProductClient) Interceptors() []Interceptor {
	return c.inters.Product
}

func (c *ProductClient) mutate(ctx context.Context, m *ProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Product mutation op: %q", m.Op())
	}
}

// ProductAddedEventClient is a client for the ProductAddedEvent schema.
type ProductAddedEventClient struct {
	config
}

// NewProductAddedEventClient returns a client for the ProductAddedEvent from the given config.
func NewProductAddedEventClient(c config) *ProductAddedEventClient {
	return &ProductAddedEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productaddedevent.Hooks(f(g(h())))`.
func (c *ProductAddedEventClient) Use(hooks ...Hook) {
	c.hooks.ProductAddedEvent = append(c.hooks.ProductAddedEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productaddedevent.Intercept(f(g(h())))`.
func (c *ProductAddedEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductAddedEvent = append(c.inters.ProductAddedEvent, interceptors...)
}

// Create returns a builder for creating a ProductAddedEvent entity.
func (c *ProductAddedEventClient) Create() *ProductAddedEventCreate {
	mutation := newProductAddedEventMutation(c.config, OpCreate)
	return &ProductAddedEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductAddedEvent entities.
func (c *ProductAddedEventClient) CreateBulk(builders ...*ProductAddedEventCreate) *ProductAddedEventCreateBulk {
	return &ProductAddedEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductAddedEventClient) MapCreateBulk(slice any, setFunc func(*ProductAddedEventCreate, int)) *ProductAddedEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductAddedEventCreateBulk{err: fmt.Errorf("calling to ProductAddedEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductAddedEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductAddedEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductAddedEvent.
func (c *ProductAddedEventClient) Update() *ProductAddedEventUpdate {
	mutation := newProductAddedEventMutation(c.config, OpUpdate)
	return &ProductAddedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductAddedEventClient) UpdateOne(_m *ProductAddedEvent) *ProductAddedEventUpdateOne {
	mutation := newProductAddedEventMutation(c.config, OpUpdateOne, withProductAddedEvent(_m))
	return &ProductAddedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductAddedEventClient) UpdateOneID(id int) *ProductAddedEventUpdateOne {
	mutation := newProductAddedEventMutation(c.config, OpUpdateOne, withProductAddedEventID(id))
	return &ProductAddedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductAddedEvent.
func (c *ProductAddedEventClient) Delete() *ProductAddedEventDelete {
	mutation := newProductAddedEventMutation(c.config, OpDelete)
	return &ProductAddedEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductAddedEventClient) DeleteOne(_m *ProductAddedEvent) *ProductAddedEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductAddedEventClient) DeleteOneID(id int) *ProductAddedEventDeleteOne {
	builder := c.Delete().Where(productaddedevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductAddedEventDeleteOne{builder}
}

// Query returns a query builder for ProductAddedEvent.
func (c *ProductAddedEventClient) Query() *ProductAddedEventQuery {
	return &ProductAddedEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductAddedEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductAddedEvent entity by its id.
func (c *ProductAddedEventClient) Get(ctx context.Context, id int) (*ProductAddedEvent, error) {
	return c.Query().Where(productaddedevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductAddedEventClient) GetX(ctx context.Context, id int) *ProductAddedEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a ProductAddedEvent.
func (c *ProductAddedEventClient) QueryEvent(_m *ProductAddedEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productaddedevent.Table, productaddedevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, productaddedevent.EventTable, productaddedevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductAddedEventClient) Hooks() []Hook {
	return c.hooks.ProductAddedEvent
}

// Interceptors returns the client interceptors.
func (c *ProductAddedEventClient) Interceptors() []Interceptor {
	return c.inters.ProductAddedEvent
}

func (c *ProductAddedEventClient) mutate(ctx context.Context, m *ProductAddedEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductAddedEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductAddedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductAddedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductAddedEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductAddedEvent mutation op: %q", m.Op())
	}
}

// ProductRemovedEventClient is a client for the ProductRemovedEvent schema.
type ProductRemovedEventClient struct {
	config
}

// NewProductRemovedEventClient returns a client for the ProductRemovedEvent from the given config.
func NewProductRemovedEventClient(c config) *ProductRemovedEventClient {
	return &ProductRemovedEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productremovedevent.Hooks(f(g(h())))`.
func (c *ProductRemovedEventClient) Use(hooks ...Hook) {
	c.hooks.ProductRemovedEvent = append(c.hooks.ProductRemovedEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productremovedevent.Intercept(f(g(h())))`.
func (c *ProductRemovedEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductRemovedEvent = append(c.inters.ProductRemovedEvent, interceptors...)
}

// Create returns a builder for creating a ProductRemovedEvent entity.
func (c *ProductRemovedEventClient) Create() *ProductRemovedEventCreate {
	mutation := newProductRemovedEventMutation(c.config, OpCreate)
	return &ProductRemovedEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductRemovedEvent entities.
func (c *ProductRemovedEventClient) CreateBulk(builders ...*ProductRemovedEventCreate) *ProductRemovedEventCreateBulk {
	return &ProductRemovedEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductRemovedEventClient) MapCreateBulk(slice any, setFunc func(*ProductRemovedEventCreate, int)) *ProductRemovedEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductRemovedEventCreateBulk{err: fmt.Errorf("calling to ProductRemovedEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductRemovedEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductRemovedEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductRemovedEvent.
func (c *ProductRemovedEventClient) Update() *ProductRemovedEventUpdate {
	mutation := newProductRemovedEventMutation(c.config, OpUpdate)
	return &ProductRemovedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductRemovedEventClient) UpdateOne(_m *ProductRemovedEvent) *ProductRemovedEventUpdateOne {
	mutation := newProductRemovedEventMutation(c.config, OpUpdateOne, withProductRemovedEvent(_m))
	return &ProductRemovedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductRemovedEventClient) UpdateOneID(id int) *ProductRemovedEventUpdateOne {
	mutation := newProductRemovedEventMutation(c.config, OpUpdateOne, withProductRemovedEventID(id))
	return &ProductRemovedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductRemovedEvent.
func (c *ProductRemovedEventClient) Delete() *ProductRemovedEventDelete {
	mutation := newProductRemovedEventMutation(c.config, OpDelete)
	return &ProductRemovedEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductRemovedEventClient) DeleteOne(_m *ProductRemovedEvent) *ProductRemovedEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductRemovedEventClient) DeleteOneID(id int) *ProductRemovedEventDeleteOne {
	builder := c.Delete().Where(productremovedevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductRemovedEventDeleteOne{builder}
}

// Query returns a query builder for ProductRemovedEvent.
func (c *ProductRemovedEventClient) Query() *ProductRemovedEventQuery {
	return &ProductRemovedEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductRemovedEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductRemovedEvent entity by its id.
func (c *ProductRemovedEventClient) Get(ctx context.Context, id int) (*ProductRemovedEvent, error) {
	return c.Query().Where(productremovedevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductRemovedEventClient) GetX(ctx context.Context, id int) *ProductRemovedEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a ProductRemovedEvent.
func (c *ProductRemovedEventClient) QueryEvent(_m *ProductRemovedEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productremovedevent.Table, productremovedevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, productremovedevent.EventTable, productremovedevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductRemovedEventClient) Hooks() []Hook {
	return c.hooks.ProductRemovedEvent
}

// Interceptors returns the client interceptors.
func (c *ProductRemovedEventClient) Interceptors() []Interceptor {
	return c.inters.ProductRemovedEvent
}

func (c *ProductRemovedEventClient) mutate(ctx context.Context, m *ProductRemovedEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductRemovedEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductRemovedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductRemovedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductRemovedEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductRemovedEvent mutation op: %q", m.Op())
	}
}

// ProjectStartedEventClient is a client for the ProjectStartedEvent schema.
type ProjectStartedEventClient struct {
	config
}

// NewProjectStartedEventClient returns a client for the ProjectStartedEvent from the given config.
func NewProjectStartedEventClient(c config) *ProjectStartedEventClient {
	return &ProjectStartedEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `projectstartedevent.Hooks(f(g(h())))`.
func (c *ProjectStartedEventClient) Use(hooks ...Hook) {
	c.hooks.ProjectStartedEvent = append(c.hooks.ProjectStartedEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `projectstartedevent.Intercept(f(g(h())))`.
func (c *ProjectStartedEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProjectStartedEvent = append(c.inters.ProjectStartedEvent, interceptors...)
}

// Create returns a builder for creating a ProjectStartedEvent entity.
func (c *ProjectStartedEventClient) Create() *ProjectStartedEventCreate {
	mutation := newProjectStartedEventMutation(c.config, OpCreate)
	return &ProjectStartedEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProjectStartedEvent entities.
func (c *ProjectStartedEventClient) CreateBulk(builders ...*ProjectStartedEventCreate) *ProjectStartedEventCreateBulk {
	return &ProjectStartedEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectStartedEventClient) MapCreateBulk(slice any, setFunc func(*ProjectStartedEventCreate, int)) *ProjectStartedEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectStartedEventCreateBulk{err: fmt.Errorf("calling to ProjectStartedEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectStartedEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectStartedEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProjectStartedEvent.
func (c *ProjectStartedEventClient) Update() *ProjectStartedEventUpdate {
	mutation := newProjectStartedEventMutation(c.config, OpUpdate)
	return &ProjectStartedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectStartedEventClient) UpdateOne(_m *ProjectStartedEvent) *ProjectStartedEventUpdateOne {
	mutation := newProjectStartedEventMutation(c.config, OpUpdateOne, withProjectStartedEvent(_m))
	return &ProjectStartedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectStartedEventClient) UpdateOneID(id uuid.UUID) *ProjectStartedEventUpdateOne {
	mutation := newProjectStartedEventMutation(c.config, OpUpdateOne, withProjectStartedEventID(id))
	return &ProjectStartedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProjectStartedEvent.
func (c *ProjectStartedEventClient) Delete() *ProjectStartedEventDelete {
	mutation := newProjectStartedEventMutation(c.config, OpDelete)
	return &ProjectStartedEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectStartedEventClient) DeleteOne(_m *ProjectStartedEvent) *ProjectStartedEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectStartedEventClient) DeleteOneID(id uuid.UUID) *ProjectStartedEventDeleteOne {
	builder := c.Delete().Where(projectstartedevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectStartedEventDeleteOne{builder}
}

// Query returns a query builder for ProjectStartedEvent.
func (c *ProjectStartedEventClient) Query() *ProjectStartedEventQuery {
	return &ProjectStartedEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProjectStartedEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a ProjectStartedEvent entity by its id.
func (c *ProjectStartedEventClient) Get(ctx context.Context, id uuid.UUID) (*ProjectStartedEvent, error) {
	return c.Query().Where(projectstartedevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectStartedEventClient) GetX(ctx context.Context, id uuid.UUID) *ProjectStartedEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a ProjectStartedEvent.
func (c *ProjectStartedEventClient) QueryEvent(_m *ProjectStartedEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(projectstartedevent.Table, projectstartedevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, projectstartedevent.EventTable, projectstartedevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectStartedEventClient) Hooks() []Hook {
	return c.hooks.ProjectStartedEvent
}

// Interceptors returns the client interceptors.
func (c *ProjectStartedEventClient) Interceptors() []Interceptor {
	return c.inters.ProjectStartedEvent
}

func (c *ProjectStartedEventClient) mutate(ctx context.Context, m *ProjectStartedEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectStartedEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectStartedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectStartedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectStartedEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProjectStartedEvent mutation op: %q", m.Op())
	}
}

// StartDateChangedEventClient is a client for the StartDateChangedEvent schema.
type StartDateChangedEventClient struct {
	config
}

// NewStartDateChangedEventClient returns a client for the StartDateChangedEvent from the given config.
func NewStartDateChangedEventClient(c config) *StartDateChangedEventClient {
	return &StartDateChangedEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `startdatechangedevent.Hooks(f(g(h())))`.
func (c *StartDateChangedEventClient) Use(hooks ...Hook) {
	c.hooks.StartDateChangedEvent = append(c.hooks.StartDateChangedEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `startdatechangedevent.Intercept(f(g(h())))`.
func (c *StartDateChangedEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.StartDateChangedEvent = append(c.inters.StartDateChangedEvent, interceptors...)
}

// Create returns a builder for creating a StartDateChangedEvent entity.
func (c *StartDateChangedEventClient) Create() *StartDateChangedEventCreate {
	mutation := newStartDateChangedEventMutation(c.config, OpCreate)
	return &StartDateChangedEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StartDateChangedEvent entities.
func (c *StartDateChangedEventClient) CreateBulk(builders ...*StartDateChangedEventCreate) *StartDateChangedEventCreateBulk {
	return &StartDateChangedEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StartDateChangedEventClient) MapCreateBulk(slice any, setFunc func(*StartDateChangedEventCreate, int)) *StartDateChangedEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StartDateChangedEventCreateBulk{err: fmt.Errorf("calling to StartDateChangedEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StartDateChangedEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StartDateChangedEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StartDateChangedEvent.
func (c *StartDateChangedEventClient) Update() *StartDateChangedEventUpdate {
	mutation := newStartDateChangedEventMutation(c.config, OpUpdate)
	return &StartDateChangedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StartDateChangedEventClient) UpdateOne(_m *StartDateChangedEvent) *StartDateChangedEventUpdateOne {
	mutation := newStartDateChangedEventMutation(c.config, OpUpdateOne, withStartDateChangedEvent(_m))
	return &StartDateChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StartDateChangedEventClient) UpdateOneID(id uuid.UUID) *StartDateChangedEventUpdateOne {
	mutation := newStartDateChangedEventMutation(c.config, OpUpdateOne, withStartDateChangedEventID(id))
	return &StartDateChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StartDateChangedEvent.
func (c *StartDateChangedEventClient) Delete() *StartDateChangedEventDelete {
	mutation := newStartDateChangedEventMutation(c.config, OpDelete)
	return &StartDateChangedEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StartDateChangedEventClient) DeleteOne(_m *StartDateChangedEvent) *StartDateChangedEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StartDateChangedEventClient) DeleteOneID(id uuid.UUID) *StartDateChangedEventDeleteOne {
	builder := c.Delete().Where(startdatechangedevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StartDateChangedEventDeleteOne{builder}
}

// Query returns a query builder for StartDateChangedEvent.
func (c *StartDateChangedEventClient) Query() *StartDateChangedEventQuery {
	return &StartDateChangedEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStartDateChangedEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a StartDateChangedEvent entity by its id.
func (c *StartDateChangedEventClient) Get(ctx context.Context, id uuid.UUID) (*StartDateChangedEvent, error) {
	return c.Query().Where(startdatechangedevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StartDateChangedEventClient) GetX(ctx context.Context, id uuid.UUID) *StartDateChangedEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a StartDateChangedEvent.
func (c *StartDateChangedEventClient) QueryEvent(_m *StartDateChangedEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(startdatechangedevent.Table, startdatechangedevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, startdatechangedevent.EventTable, startdatechangedevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StartDateChangedEventClient) Hooks() []Hook {
	return c.hooks.StartDateChangedEvent
}

// Interceptors returns the client interceptors.
func (c *StartDateChangedEventClient) Interceptors() []Interceptor {
	return c.inters.StartDateChangedEvent
}

func (c *StartDateChangedEventClient) mutate(ctx context.Context, m *StartDateChangedEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StartDateChangedEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StartDateChangedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StartDateChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StartDateChangedEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StartDateChangedEvent mutation op: %q", m.Op())
	}
}

// TitleChangedEventClient is a client for the TitleChangedEvent schema.
type TitleChangedEventClient struct {
	config
}

// NewTitleChangedEventClient returns a client for the TitleChangedEvent from the given config.
func NewTitleChangedEventClient(c config) *TitleChangedEventClient {
	return &TitleChangedEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `titlechangedevent.Hooks(f(g(h())))`.
func (c *TitleChangedEventClient) Use(hooks ...Hook) {
	c.hooks.TitleChangedEvent = append(c.hooks.TitleChangedEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `titlechangedevent.Intercept(f(g(h())))`.
func (c *TitleChangedEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.TitleChangedEvent = append(c.inters.TitleChangedEvent, interceptors...)
}

// Create returns a builder for creating a TitleChangedEvent entity.
func (c *TitleChangedEventClient) Create() *TitleChangedEventCreate {
	mutation := newTitleChangedEventMutation(c.config, OpCreate)
	return &TitleChangedEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TitleChangedEvent entities.
func (c *TitleChangedEventClient) CreateBulk(builders ...*TitleChangedEventCreate) *TitleChangedEventCreateBulk {
	return &TitleChangedEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TitleChangedEventClient) MapCreateBulk(slice any, setFunc func(*TitleChangedEventCreate, int)) *TitleChangedEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TitleChangedEventCreateBulk{err: fmt.Errorf("calling to TitleChangedEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TitleChangedEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TitleChangedEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TitleChangedEvent.
func (c *TitleChangedEventClient) Update() *TitleChangedEventUpdate {
	mutation := newTitleChangedEventMutation(c.config, OpUpdate)
	return &TitleChangedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TitleChangedEventClient) UpdateOne(_m *TitleChangedEvent) *TitleChangedEventUpdateOne {
	mutation := newTitleChangedEventMutation(c.config, OpUpdateOne, withTitleChangedEvent(_m))
	return &TitleChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TitleChangedEventClient) UpdateOneID(id uuid.UUID) *TitleChangedEventUpdateOne {
	mutation := newTitleChangedEventMutation(c.config, OpUpdateOne, withTitleChangedEventID(id))
	return &TitleChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TitleChangedEvent.
func (c *TitleChangedEventClient) Delete() *TitleChangedEventDelete {
	mutation := newTitleChangedEventMutation(c.config, OpDelete)
	return &TitleChangedEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TitleChangedEventClient) DeleteOne(_m *TitleChangedEvent) *TitleChangedEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TitleChangedEventClient) DeleteOneID(id uuid.UUID) *TitleChangedEventDeleteOne {
	builder := c.Delete().Where(titlechangedevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TitleChangedEventDeleteOne{builder}
}

// Query returns a query builder for TitleChangedEvent.
func (c *TitleChangedEventClient) Query() *TitleChangedEventQuery {
	return &TitleChangedEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTitleChangedEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a TitleChangedEvent entity by its id.
func (c *TitleChangedEventClient) Get(ctx context.Context, id uuid.UUID) (*TitleChangedEvent, error) {
	return c.Query().Where(titlechangedevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TitleChangedEventClient) GetX(ctx context.Context, id uuid.UUID) *TitleChangedEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a TitleChangedEvent.
func (c *TitleChangedEventClient) QueryEvent(_m *TitleChangedEvent) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(titlechangedevent.Table, titlechangedevent.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, titlechangedevent.EventTable, titlechangedevent.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TitleChangedEventClient) Hooks() []Hook {
	return c.hooks.TitleChangedEvent
}

// Interceptors returns the client interceptors.
func (c *TitleChangedEventClient) Interceptors() []Interceptor {
	return c.inters.TitleChangedEvent
}

func (c *TitleChangedEventClient) mutate(ctx context.Context, m *TitleChangedEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TitleChangedEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TitleChangedEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TitleChangedEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TitleChangedEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TitleChangedEvent mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		DescriptionChangedEvent, EndDateChangedEvent, Event, Notification, Organisation,
		OrganisationChangedEvent, Person, PersonAddedEvent, PersonRemovedEvent,
		Product, ProductAddedEvent, ProductRemovedEvent, ProjectStartedEvent,
		StartDateChangedEvent, TitleChangedEvent, User []ent.Hook
	}
	inters struct {
		DescriptionChangedEvent, EndDateChangedEvent, Event, Notification, Organisation,
		OrganisationChangedEvent, Person, PersonAddedEvent, PersonRemovedEvent,
		Product, ProductAddedEvent, ProductRemovedEvent, ProjectStartedEvent,
		StartDateChangedEvent, TitleChangedEvent, User []ent.Interceptor
	}
)
