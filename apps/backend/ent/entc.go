//go:build ignore
// +build ignore

package main

import (
	"encoding/json"
	"log"
	"os"
	"path/filepath"
	"strings"

	"entgo.io/contrib/entoas"
	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"
	openapi2 "github.com/getkin/kin-openapi/openapi2"
	openapi2conv "github.com/getkin/kin-openapi/openapi2conv"
	"github.com/ogen-go/ogen"
	"github.com/sirupsen/logrus"
)

func main() {
	// --- Step 1: Load Swag-generated spec for custom endpoints ---
	// Path to the swagger.json generated by `swag init`
	// Note: go generate runs from the ent directory, so we reference ../api/...
	swagSpecPath := filepath.Join("..", "api", "swag-docs", "swagger.json")
	swagSpec := ogen.NewSpec()

	swagBytes, err := os.ReadFile(swagSpecPath)
	if err != nil {
		// Log a warning if swag's output isn't found, but don't fail generation here.
		// It's crucial for Turborepo's dependency graph to ensure `swag-init` runs first.
		logrus.Fatalf(" Could not read swag-generated spec from %s. Custom endpoints might be missing from final OpenAPI. Error: %v", swagSpecPath, err)
	}

	var meta struct {
		Swagger string `json:"swagger"`
		OpenAPI string `json:"openapi"`
	}
	if err := json.Unmarshal(swagBytes, &meta); err != nil {
		logrus.Fatalf("failed to inspect swag-generated spec version: %v", err)
	}

	switch {
	case strings.HasPrefix(meta.Swagger, "2."):
		var swaggerDoc openapi2.T
		if err := json.Unmarshal(swagBytes, &swaggerDoc); err != nil {
			logrus.Fatalf("failed to unmarshal swagger v2 spec: %v", err)
		}
		openapi3Doc, err := openapi2conv.ToV3(&swaggerDoc)
		if err != nil {
			logrus.Fatalf("failed to convert swagger v2 spec to openapi v3: %v", err)
		}
		convertedBytes, err := openapi3Doc.MarshalJSON()
		if err != nil {
			logrus.Fatalf("failed to marshal converted openapi spec: %v", err)
		}
		if err := json.Unmarshal(convertedBytes, swagSpec); err != nil {
			logrus.Fatalf("failed to load converted openapi spec: %v", err)
		}
		logrus.Infof("INFO: Converted swagger v2 spec from %s to OpenAPI v3", swagSpecPath)
	case strings.HasPrefix(meta.OpenAPI, "3."):
		if err := json.Unmarshal(swagBytes, swagSpec); err != nil {
			logrus.Fatalf("failed to unmarshal openapi v3 spec: %v", err)
		}
		logrus.Infof("INFO: Loaded OpenAPI v%s spec from %s", meta.OpenAPI, swagSpecPath)
	default:
		if err := json.Unmarshal(swagBytes, swagSpec); err != nil {
			logrus.Fatalf("failed to unmarshal swagger spec with unknown version: %v", err)
		}
		logrus.Infof("WARN: Swagger spec version not detected; attempting to use raw document from %s", swagSpecPath)
	}

	// openapi2conv does not convert security definitions to components when the spec lacks them, so ensure components exist.
	if swagSpec.Components == nil {
		swagSpec.SetComponents(&ogen.Components{})
	}

	// Prepare output destination for entoas generated spec.
	specOutputPath := filepath.Join("api", "openapi.json")
	if err := os.MkdirAll(filepath.Dir(specOutputPath), 0o755); err != nil {
		logrus.Fatalf("failed to ensure OpenAPI output directory: %v", err)
	}
	specFile, err := os.Create(specOutputPath)
	if err != nil {
		logrus.Fatalf("failed to create OpenAPI output file: %v", err)
	}
	defer func() {
		if cerr := specFile.Close(); cerr != nil {
			logrus.Infof("WARN: failed to close OpenAPI output file: %v", cerr)
		}
	}()

	// Seed entoas with base metadata that we control.
	baseSpec := ogen.NewSpec().
		SetOpenAPI("3.0.3").
		SetInfo(ogen.NewInfo().
			SetTitle("Your App API (Merged)").
			SetDescription("An API combining Ent-generated operations with custom endpoints (via swag).").
			SetVersion("1.0.0"),
		)

	// --- Step 2: Configure entoas to generate Ent-specific parts and merge custom parts ---
	ex, err := entoas.NewExtension(
		entoas.Spec(baseSpec),
		entoas.WriteTo(specFile),
		entoas.DefaultPolicy(entoas.PolicyExclude),
		entoas.Mutations(func(graph *gen.Graph, entoasSpec *ogen.Spec) error {
			// Ensure entoas structures are initialized before mutation.
			entoasSpec.Init()

			// Ensure the bearer auth definition exists if it wasn't supplied by the swagger spec.
			if entoasSpec.Components == nil {
				entoasSpec.SetComponents(&ogen.Components{})
			}
			if entoasSpec.Components.SecuritySchemes == nil {
				entoasSpec.Components.SecuritySchemes = make(map[string]*ogen.SecurityScheme)
			}
			if _, exists := entoasSpec.Components.SecuritySchemes["BearerAuth"]; !exists {
				entoasSpec.Components.SecuritySchemes["BearerAuth"] = &ogen.SecurityScheme{
					Type:         "http",
					Scheme:       "bearer",
					BearerFormat: "JWT",
				}
			}

			// === Merge swagSpec into the entoas-generated spec ===
			if title := swagSpec.Info.Title; title != "" {
				entoasSpec.Info.Title = title
			}
			if desc := swagSpec.Info.Description; desc != "" {
				entoasSpec.Info.Description = desc
			}
			if version := swagSpec.Info.Version; version != "" {
				entoasSpec.Info.Version = version
			}

			if swagSpec.Paths != nil {
				if entoasSpec.Paths == nil {
					entoasSpec.Paths = make(ogen.Paths)
				}
				for path, item := range swagSpec.Paths {
					entoasSpec.Paths[path] = item
				}
				logrus.Infof("INFO: Merged %d custom paths from swag-generated spec.", len(swagSpec.Paths))
			}

			if swagSpec.Components != nil {
				swagSpec.Components.Init()
				if entoasSpec.Components == nil {
					entoasSpec.SetComponents(&ogen.Components{})
				}
				entoasSpec.Components.Init()

				for name, schema := range swagSpec.Components.Schemas {
					entoasSpec.Components.Schemas[name] = schema
				}
				for name, resp := range swagSpec.Components.Responses {
					entoasSpec.Components.Responses[name] = resp
				}
				for name, sec := range swagSpec.Components.SecuritySchemes {
					entoasSpec.Components.SecuritySchemes[name] = sec
				}
				if len(swagSpec.Components.Schemas) > 0 {
					logrus.Infof("INFO: Merged %d custom schemas/components from swag-generated spec.", len(swagSpec.Components.Schemas))
				}
			}

			// Apply security requirements to operations tagged with User.
			for _, item := range entoasSpec.Paths {
				if item == nil {
					continue
				}
				operations := []*ogen.Operation{item.Get, item.Put, item.Post, item.Delete, item.Options, item.Head, item.Patch, item.Trace}
				for _, op := range operations {
					if op == nil {
						continue
					}
					for _, tag := range op.Tags {
						if tag == "User" {
							op.Security = append(op.Security, ogen.SecurityRequirement{
								"BearerAuth": []string{},
							})
							break
						}
					}
				}
			}

			return nil
		}),
	)
	if err != nil {
		logrus.Fatalf("creating entoas extension: %v", err)
	}

	err = entc.Generate("./schema", &gen.Config{
		Features: []gen.Feature{gen.FeatureVersionedMigration},
	}, entc.Extensions(ex))

	if err != nil {
		logrus.Fatalf("running ent code generation: %v", err)
	}

	log.Println("Ent code and OpenAPI spec generated successfully, including custom endpoints from swag.")
}
