// Code generated by gen/generator.go. DO NOT EDIT.

package events

import (
	"context"
	"errors"
	"fmt"
	projdomain "github.com/SURF-Innovatie/MORIS/internal/domain/project"
	"github.com/google/uuid"
	"time"
)

// --- TitleChanged ---

const TitleChangedType = "project.title_changed"

type TitleChanged struct {
	Base
	Title string `json:"title"`
}

func (TitleChanged) isEvent()     {}
func (TitleChanged) Type() string { return TitleChangedType }
func (e TitleChanged) String() string {
	return "Title Change: " + fmt.Sprint(e.Title)
}

func (e *TitleChanged) Apply(project *projdomain.Project) {
	project.Title = e.Title
}

func (e *TitleChanged) NotificationTemplate() string {
	return "Project title changed to '{{event.Title}}'"
}

func (e *TitleChanged) ApprovalRequestTemplate() string {
	return "Request to change project title to '{{event.Title}}' requires approval"
}

func (e *TitleChanged) ApprovedTemplate() string {
	return "Title change to '{{event.Title}}' approved"
}

func (e *TitleChanged) RejectedTemplate() string {
	return "Title change to '{{event.Title}}' rejected"
}

func (e *TitleChanged) NotificationVariables() map[string]string {
	return map[string]string{
		"event.Title": fmt.Sprint(e.Title),
	}
}

type TitleChangedInput struct {
	Title string `json:"title"`
}

func DecideTitleChanged(
	projectID uuid.UUID,
	actor uuid.UUID,
	cur *projdomain.Project,
	in TitleChangedInput,
	status Status,
) (Event, error) {
	if projectID == uuid.Nil {
		return nil, errors.New("project id is required")
	}
	if cur == nil {
		return nil, errors.New("current project is required")
	}
	if in.Title == "" {
		return nil, nil
	}
	if cur.Title == in.Title {
		return nil, nil
	}
	base := NewBase(projectID, actor, status)
	base.FriendlyNameStr = TitleChangedMeta.FriendlyName

	return &TitleChanged{
		Base:  base,
		Title: in.Title,
	}, nil
}

var TitleChangedMeta = EventMeta{
	Type:         TitleChangedType,
	FriendlyName: "Title Change",
}

// --- DescriptionChanged ---

const DescriptionChangedType = "project.description_changed"

type DescriptionChanged struct {
	Base
	Description string `json:"description"`
}

func (DescriptionChanged) isEvent()     {}
func (DescriptionChanged) Type() string { return DescriptionChangedType }
func (e DescriptionChanged) String() string {
	return "Description Change: " + fmt.Sprint(e.Description)
}

func (e *DescriptionChanged) Apply(project *projdomain.Project) {
	project.Description = e.Description
}

func (e *DescriptionChanged) NotificationTemplate() string {
	return "Project description has been updated"
}

func (e *DescriptionChanged) ApprovalRequestTemplate() string {
	return "Changing project description requires approval."
}

func (e *DescriptionChanged) ApprovedTemplate() string {
	return "Project description change has been approved."
}

func (e *DescriptionChanged) RejectedTemplate() string {
	return "Project description change has been rejected."
}

func (e *DescriptionChanged) NotificationVariables() map[string]string {
	return map[string]string{
		"event.Description": fmt.Sprint(e.Description),
	}
}

type DescriptionChangedInput struct {
	Description string `json:"description"`
}

func DecideDescriptionChanged(
	projectID uuid.UUID,
	actor uuid.UUID,
	cur *projdomain.Project,
	in DescriptionChangedInput,
	status Status,
) (Event, error) {
	if projectID == uuid.Nil {
		return nil, errors.New("project id is required")
	}
	if cur == nil {
		return nil, errors.New("current project is required")
	}
	if cur.Description == in.Description {
		return nil, nil
	}
	base := NewBase(projectID, actor, status)
	base.FriendlyNameStr = DescriptionChangedMeta.FriendlyName

	return &DescriptionChanged{
		Base:        base,
		Description: in.Description,
	}, nil
}

var DescriptionChangedMeta = EventMeta{
	Type:         DescriptionChangedType,
	FriendlyName: "Description Change",
}

// --- StartDateChanged ---

const StartDateChangedType = "project.start_date_changed"

type StartDateChanged struct {
	Base
	StartDate time.Time `json:"startDate"`
}

func (StartDateChanged) isEvent()     {}
func (StartDateChanged) Type() string { return StartDateChangedType }
func (e StartDateChanged) String() string {
	return "Start Date Change: " + fmt.Sprint(e.StartDate.Format("2006-01-02"))
}

func (e *StartDateChanged) Apply(project *projdomain.Project) {
	project.StartDate = e.StartDate
}

func (e *StartDateChanged) NotificationTemplate() string {
	return "Project start date changed to {{event.StartDate}}"
}

func (e *StartDateChanged) ApprovalRequestTemplate() string {
	return "Request to change start date to {{event.StartDate}} requires approval"
}

func (e *StartDateChanged) ApprovedTemplate() string {
	return "Start date change to {{event.StartDate}} approved"
}

func (e *StartDateChanged) RejectedTemplate() string {
	return "Start date change to {{event.StartDate}} rejected"
}

func (e *StartDateChanged) NotificationVariables() map[string]string {
	return map[string]string{
		"event.StartDate": fmt.Sprint(e.StartDate),
	}
}

type StartDateChangedInput struct {
	StartDate time.Time `json:"startDate"`
}

func DecideStartDateChanged(
	projectID uuid.UUID,
	actor uuid.UUID,
	cur *projdomain.Project,
	in StartDateChangedInput,
	status Status,
) (Event, error) {
	if projectID == uuid.Nil {
		return nil, errors.New("project id is required")
	}
	if cur == nil {
		return nil, errors.New("current project is required")
	}
	if cur.StartDate.Equal(in.StartDate) {
		return nil, nil
	}
	base := NewBase(projectID, actor, status)
	base.FriendlyNameStr = StartDateChangedMeta.FriendlyName

	return &StartDateChanged{
		Base:      base,
		StartDate: in.StartDate,
	}, nil
}

var StartDateChangedMeta = EventMeta{
	Type:         StartDateChangedType,
	FriendlyName: "Start Date Change",
}

// --- EndDateChanged ---

const EndDateChangedType = "project.end_date_changed"

type EndDateChanged struct {
	Base
	EndDate time.Time `json:"endDate"`
}

func (EndDateChanged) isEvent()     {}
func (EndDateChanged) Type() string { return EndDateChangedType }
func (e EndDateChanged) String() string {
	return "End Date Change: " + fmt.Sprint(e.EndDate.Format("2006-01-02"))
}

func (e *EndDateChanged) Apply(project *projdomain.Project) {
	project.EndDate = e.EndDate
}

func (e *EndDateChanged) NotificationTemplate() string {
	return "Project end date changed to {{event.EndDate}}"
}

func (e *EndDateChanged) ApprovalRequestTemplate() string {
	return "Request to change end date to {{event.EndDate}} requires approval"
}

func (e *EndDateChanged) ApprovedTemplate() string {
	return "End date change to {{event.EndDate}} approved"
}

func (e *EndDateChanged) RejectedTemplate() string {
	return "End date change to {{event.EndDate}} rejected"
}

func (e *EndDateChanged) NotificationVariables() map[string]string {
	return map[string]string{
		"event.EndDate": fmt.Sprint(e.EndDate),
	}
}

type EndDateChangedInput struct {
	EndDate time.Time `json:"endDate"`
}

func DecideEndDateChanged(
	projectID uuid.UUID,
	actor uuid.UUID,
	cur *projdomain.Project,
	in EndDateChangedInput,
	status Status,
) (Event, error) {
	if projectID == uuid.Nil {
		return nil, errors.New("project id is required")
	}
	if cur == nil {
		return nil, errors.New("current project is required")
	}
	if cur.EndDate.Equal(in.EndDate) {
		return nil, nil
	}
	base := NewBase(projectID, actor, status)
	base.FriendlyNameStr = EndDateChangedMeta.FriendlyName

	return &EndDateChanged{
		Base:    base,
		EndDate: in.EndDate,
	}, nil
}

var EndDateChangedMeta = EventMeta{
	Type:         EndDateChangedType,
	FriendlyName: "End Date Change",
}

// --- OwningOrgNodeChanged ---

const OwningOrgNodeChangedType = "project.owning_org_node_changed"

type OwningOrgNodeChanged struct {
	Base
	OwningOrgNodeID uuid.UUID `json:"owning_org_node_id"`
}

func (OwningOrgNodeChanged) isEvent()     {}
func (OwningOrgNodeChanged) Type() string { return OwningOrgNodeChangedType }
func (e OwningOrgNodeChanged) String() string {
	return "Owning Organisation Node Change: " + fmt.Sprint(e.OwningOrgNodeID)
}

func (e *OwningOrgNodeChanged) Apply(project *projdomain.Project) {
	project.OwningOrgNodeID = e.OwningOrgNodeID
}

func (e *OwningOrgNodeChanged) NotificationTemplate() string {
	return "Project transferred to organisation '{{org_node.Name}}'"
}

func (e *OwningOrgNodeChanged) ApprovalRequestTemplate() string {
	return "Request to transfer project to '{{org_node.Name}}' requires approval"
}

func (e *OwningOrgNodeChanged) ApprovedTemplate() string {
	return "Transfer to '{{org_node.Name}}' approved"
}

func (e *OwningOrgNodeChanged) RejectedTemplate() string {
	return "Transfer to '{{org_node.Name}}' rejected"
}

func (e *OwningOrgNodeChanged) NotificationVariables() map[string]string {
	return map[string]string{
		"event.OwningOrgNodeID": fmt.Sprint(e.OwningOrgNodeID),
	}
}

func (e *OwningOrgNodeChanged) RelatedIDs() RelatedIDs {
	return RelatedIDs{OrgNodeID: &e.OwningOrgNodeID}
}

type OwningOrgNodeChangedInput struct {
	OwningOrgNodeID uuid.UUID `json:"owning_org_node_id"`
}

func DecideOwningOrgNodeChanged(
	projectID uuid.UUID,
	actor uuid.UUID,
	cur *projdomain.Project,
	in OwningOrgNodeChangedInput,
	status Status,
) (Event, error) {
	if projectID == uuid.Nil {
		return nil, errors.New("project id is required")
	}
	if cur == nil {
		return nil, errors.New("current project is required")
	}
	if in.OwningOrgNodeID == uuid.Nil {
		return nil, errors.New("owning_org_node_id is required")
	}
	if cur.OwningOrgNodeID == in.OwningOrgNodeID {
		return nil, nil
	}
	base := NewBase(projectID, actor, status)
	base.FriendlyNameStr = OwningOrgNodeChangedMeta.FriendlyName

	return &OwningOrgNodeChanged{
		Base:            base,
		OwningOrgNodeID: in.OwningOrgNodeID,
	}, nil
}

var OwningOrgNodeChangedMeta = EventMeta{
	Type:         OwningOrgNodeChangedType,
	FriendlyName: "Owning Organisation Node Change",
}

func init() {
	RegisterMeta(TitleChangedMeta, func() Event {
		return &TitleChanged{Base: Base{FriendlyNameStr: TitleChangedMeta.FriendlyName}}
	})
	RegisterDecider[TitleChangedInput](TitleChangedType,
		func(ctx context.Context, projectID uuid.UUID, actor uuid.UUID, cur *projdomain.Project, in TitleChangedInput, status Status) (Event, error) {
			return DecideTitleChanged(projectID, actor, cur, in, status)
		})
	RegisterInputType(TitleChangedType, TitleChangedInput{})
	RegisterMeta(DescriptionChangedMeta, func() Event {
		return &DescriptionChanged{Base: Base{FriendlyNameStr: DescriptionChangedMeta.FriendlyName}}
	})
	RegisterDecider[DescriptionChangedInput](DescriptionChangedType,
		func(ctx context.Context, projectID uuid.UUID, actor uuid.UUID, cur *projdomain.Project, in DescriptionChangedInput, status Status) (Event, error) {
			return DecideDescriptionChanged(projectID, actor, cur, in, status)
		})
	RegisterInputType(DescriptionChangedType, DescriptionChangedInput{})
	RegisterMeta(StartDateChangedMeta, func() Event {
		return &StartDateChanged{Base: Base{FriendlyNameStr: StartDateChangedMeta.FriendlyName}}
	})
	RegisterDecider[StartDateChangedInput](StartDateChangedType,
		func(ctx context.Context, projectID uuid.UUID, actor uuid.UUID, cur *projdomain.Project, in StartDateChangedInput, status Status) (Event, error) {
			return DecideStartDateChanged(projectID, actor, cur, in, status)
		})
	RegisterInputType(StartDateChangedType, StartDateChangedInput{})
	RegisterMeta(EndDateChangedMeta, func() Event {
		return &EndDateChanged{Base: Base{FriendlyNameStr: EndDateChangedMeta.FriendlyName}}
	})
	RegisterDecider[EndDateChangedInput](EndDateChangedType,
		func(ctx context.Context, projectID uuid.UUID, actor uuid.UUID, cur *projdomain.Project, in EndDateChangedInput, status Status) (Event, error) {
			return DecideEndDateChanged(projectID, actor, cur, in, status)
		})
	RegisterInputType(EndDateChangedType, EndDateChangedInput{})
	RegisterMeta(OwningOrgNodeChangedMeta, func() Event {
		return &OwningOrgNodeChanged{Base: Base{FriendlyNameStr: OwningOrgNodeChangedMeta.FriendlyName}}
	})
	RegisterDecider[OwningOrgNodeChangedInput](OwningOrgNodeChangedType,
		func(ctx context.Context, projectID uuid.UUID, actor uuid.UUID, cur *projdomain.Project, in OwningOrgNodeChangedInput, status Status) (Event, error) {
			return DecideOwningOrgNodeChanged(projectID, actor, cur, in, status)
		})
	RegisterInputType(OwningOrgNodeChangedType, OwningOrgNodeChangedInput{})
}
