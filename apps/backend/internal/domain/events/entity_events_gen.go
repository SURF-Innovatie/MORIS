// Code generated by gen/generator.go. DO NOT EDIT.

package events

import (
	"context"
	"errors"
	"fmt"

	"github.com/SURF-Innovatie/MORIS/internal/domain/entities"
	"github.com/google/uuid"
)

// --- ProductAdded / ProductRemoved ---

const ProductAddedType = "project.product_added"
const ProductRemovedType = "project.product_removed"

type ProductAdded struct {
	Base
	ProductID uuid.UUID `json:"product_id"`
}

func (ProductAdded) isEvent()     {}
func (ProductAdded) Type() string { return ProductAddedType }
func (e ProductAdded) String() string {
	return fmt.Sprintf("Product added: %s", e.ProductID)
}

func (e *ProductAdded) Apply(project *entities.Project) {
	project.ProductIDs = append(project.ProductIDs, e.ProductID)
}

func (e *ProductAdded) RelatedIDs() RelatedIDs {
	return RelatedIDs{ProductID: &e.ProductID}
}

func (e *ProductAdded) NotificationMessage() string {
	return "A new product has been added to the project."
}

func (e *ProductAdded) NotificationTemplate() string {
	return "Product '{{product.Name}}' was added to project '{{project.Title}}'"
}

func (e *ProductAdded) ApprovalRequestTemplate() string {
	return "Request to add product '{{product.Name}}' requires approval"
}

func (e *ProductAdded) ApprovedTemplate() string {
	return "Addition of product '{{product.Name}}' approved"
}

func (e *ProductAdded) RejectedTemplate() string {
	return "Addition of product '{{product.Name}}' rejected"
}

func (e *ProductAdded) NotificationVariables() map[string]string {
	return map[string]string{
		"event.ProductID": e.ProductID.String(),
	}
}

type ProductAddedInput struct {
	ProductID uuid.UUID `json:"product_id"`
}

func DecideProductAdded(
	projectID uuid.UUID,
	actor uuid.UUID,
	cur *entities.Project,
	in ProductAddedInput,
	status Status,
) (Event, error) {
	if projectID == uuid.Nil {
		return nil, errors.New("project id is required")
	}
	if in.ProductID == uuid.Nil {
		return nil, errors.New("product_id is required")
	}
	if cur == nil {
		return nil, errors.New("current project is required")
	}
	for _, x := range cur.ProductIDs {
		if x == in.ProductID {
			return nil, fmt.Errorf("product %s already exists", in.ProductID)
		}
	}
	base := NewBase(projectID, actor, status)
	base.FriendlyNameStr = ProductAddedMeta.FriendlyName

	return &ProductAdded{
		Base:      base,
		ProductID: in.ProductID,
	}, nil
}

var ProductAddedMeta = EventMeta{
	Type:         ProductAddedType,
	FriendlyName: "Product Addition",
}

// --- ProductRemoved ---

type ProductRemoved struct {
	Base
	ProductID uuid.UUID `json:"product_id"`
}

func (ProductRemoved) isEvent()     {}
func (ProductRemoved) Type() string { return ProductRemovedType }
func (e ProductRemoved) String() string {
	return fmt.Sprintf("Product removed: %s", e.ProductID)
}

func (e *ProductRemoved) Apply(project *entities.Project) {
	for i, x := range project.ProductIDs {
		if x == e.ProductID {
			project.ProductIDs = append(project.ProductIDs[:i], project.ProductIDs[i+1:]...)
			return
		}
	}
}

func (e *ProductRemoved) RelatedIDs() RelatedIDs {
	return RelatedIDs{ProductID: &e.ProductID}
}

func (e *ProductRemoved) NotificationMessage() string {
	return "A product has been removed from the project."
}

func (e *ProductRemoved) NotificationTemplate() string {
	return "Product '{{product.Name}}' was removed from project '{{project.Title}}'"
}

func (e *ProductRemoved) ApprovalRequestTemplate() string {
	return "Request to remove product '{{product.Name}}' requires approval"
}

func (e *ProductRemoved) ApprovedTemplate() string {
	return "Removal of product '{{product.Name}}' approved"
}

func (e *ProductRemoved) RejectedTemplate() string {
	return "Removal of product '{{product.Name}}' rejected"
}

func (e *ProductRemoved) NotificationVariables() map[string]string {
	return map[string]string{
		"event.ProductID": e.ProductID.String(),
	}
}

type ProductRemovedInput struct {
	ProductID uuid.UUID `json:"product_id"`
}

func DecideProductRemoved(
	projectID uuid.UUID,
	actor uuid.UUID,
	cur *entities.Project,
	in ProductRemovedInput,
	status Status,
) (Event, error) {
	if projectID == uuid.Nil {
		return nil, errors.New("project id is required")
	}
	if in.ProductID == uuid.Nil {
		return nil, errors.New("product_id is required")
	}
	if cur == nil {
		return nil, errors.New("current project is required")
	}
	found := false
	for _, x := range cur.ProductIDs {
		if x == in.ProductID {
			found = true
			break
		}
	}
	if !found {
		return nil, fmt.Errorf("product %s not found", in.ProductID)
	}
	base := NewBase(projectID, actor, status)
	base.FriendlyNameStr = ProductRemovedMeta.FriendlyName

	return &ProductRemoved{
		Base:      base,
		ProductID: in.ProductID,
	}, nil
}

var ProductRemovedMeta = EventMeta{
	Type:         ProductRemovedType,
	FriendlyName: "Product Removal",
}

// --- BudgetLineItemAdded / BudgetLineItemRemoved ---

const BudgetLineItemAddedType = "project.budgetlineitem_added"
const BudgetLineItemRemovedType = "project.budgetlineitem_removed"

type BudgetLineItemAdded struct {
	Base
}

func (BudgetLineItemAdded) isEvent()     {}
func (BudgetLineItemAdded) Type() string { return BudgetLineItemAddedType }
func (e BudgetLineItemAdded) String() string {
	return "BudgetLineItem added"
}

func (e *BudgetLineItemAdded) Apply(project *entities.Project) {
}

func (e *BudgetLineItemAdded) RelatedIDs() RelatedIDs {
	return RelatedIDs{}
}

func (e *BudgetLineItemAdded) NotificationMessage() string {
	return "A new budgetlineitem has been added to the project."
}

func (e *BudgetLineItemAdded) NotificationTemplate() string {
	return "Budget line item '{{line_item.Description}}' was added to project '{{project.Title}}'"
}

func (e *BudgetLineItemAdded) ApprovalRequestTemplate() string {
	return "Request to add budget line item '{{line_item.Description}}' requires approval"
}

func (e *BudgetLineItemAdded) ApprovedTemplate() string {
	return "Addition of budget line item '{{line_item.Description}}' approved"
}

func (e *BudgetLineItemAdded) RejectedTemplate() string {
	return "Addition of budget line item '{{line_item.Description}}' rejected"
}

func (e *BudgetLineItemAdded) NotificationVariables() map[string]string {
	return map[string]string{}
}

type BudgetLineItemAddedInput struct {
}

func DecideBudgetLineItemAdded(
	projectID uuid.UUID,
	actor uuid.UUID,
	cur *entities.Project,
	in BudgetLineItemAddedInput,
	status Status,
) (Event, error) {
	if projectID == uuid.Nil {
		return nil, errors.New("project id is required")
	}
	if cur == nil {
		return nil, errors.New("current project is required")
	}
	base := NewBase(projectID, actor, status)
	base.FriendlyNameStr = BudgetLineItemAddedMeta.FriendlyName

	return &BudgetLineItemAdded{
		Base: base,
	}, nil
}

var BudgetLineItemAddedMeta = EventMeta{
	Type:         BudgetLineItemAddedType,
	FriendlyName: "Budget Line Item Addition",
}

// --- BudgetLineItemRemoved ---

type BudgetLineItemRemoved struct {
	Base
}

func (BudgetLineItemRemoved) isEvent()     {}
func (BudgetLineItemRemoved) Type() string { return BudgetLineItemRemovedType }
func (e BudgetLineItemRemoved) String() string {
	return "BudgetLineItem removed"
}

func (e *BudgetLineItemRemoved) Apply(project *entities.Project) {
}

func (e *BudgetLineItemRemoved) RelatedIDs() RelatedIDs {
	return RelatedIDs{}
}

func (e *BudgetLineItemRemoved) NotificationMessage() string {
	return "A budgetlineitem has been removed from the project."
}

func (e *BudgetLineItemRemoved) NotificationTemplate() string {
	return "Budget line item '{{line_item.Description}}' was removed from project '{{project.Title}}'"
}

func (e *BudgetLineItemRemoved) ApprovalRequestTemplate() string {
	return "Request to remove budget line item '{{line_item.Description}}' requires approval"
}

func (e *BudgetLineItemRemoved) ApprovedTemplate() string {
	return "Removal of budget line item '{{line_item.Description}}' approved"
}

func (e *BudgetLineItemRemoved) RejectedTemplate() string {
	return "Removal of budget line item '{{line_item.Description}}' rejected"
}

func (e *BudgetLineItemRemoved) NotificationVariables() map[string]string {
	return map[string]string{}
}

type BudgetLineItemRemovedInput struct {
}

func DecideBudgetLineItemRemoved(
	projectID uuid.UUID,
	actor uuid.UUID,
	cur *entities.Project,
	in BudgetLineItemRemovedInput,
	status Status,
) (Event, error) {
	if projectID == uuid.Nil {
		return nil, errors.New("project id is required")
	}
	if cur == nil {
		return nil, errors.New("current project is required")
	}
	base := NewBase(projectID, actor, status)
	base.FriendlyNameStr = BudgetLineItemRemovedMeta.FriendlyName

	return &BudgetLineItemRemoved{
		Base: base,
	}, nil
}

var BudgetLineItemRemovedMeta = EventMeta{
	Type:         BudgetLineItemRemovedType,
	FriendlyName: "Budget Line Item Removal",
}

// --- AffiliatedOrganisationAdded / AffiliatedOrganisationRemoved ---

const AffiliatedOrganisationAddedType = "project.affiliatedorganisation_added"
const AffiliatedOrganisationRemovedType = "project.affiliatedorganisation_removed"

type AffiliatedOrganisationAdded struct {
	Base
	AffiliatedOrganisationID uuid.UUID `json:"affiliated_organisation_id"`
}

func (AffiliatedOrganisationAdded) isEvent()     {}
func (AffiliatedOrganisationAdded) Type() string { return AffiliatedOrganisationAddedType }
func (e AffiliatedOrganisationAdded) String() string {
	return fmt.Sprintf("AffiliatedOrganisation added: %s", e.AffiliatedOrganisationID)
}

func (e *AffiliatedOrganisationAdded) Apply(project *entities.Project) {
	project.AffiliatedOrganisationIDs = append(project.AffiliatedOrganisationIDs, e.AffiliatedOrganisationID)
}

func (e *AffiliatedOrganisationAdded) RelatedIDs() RelatedIDs {
	return RelatedIDs{AffiliatedOrganisationID: &e.AffiliatedOrganisationID}
}

func (e *AffiliatedOrganisationAdded) NotificationMessage() string {
	return "A new affiliatedorganisation has been added to the project."
}

func (e *AffiliatedOrganisationAdded) NotificationTemplate() string {
	return "Organisation '{{affiliated_organisation.Name}}' was affiliated with project '{{project.Title}}'"
}

func (e *AffiliatedOrganisationAdded) ApprovalRequestTemplate() string {
	return "Request to affiliate organisation '{{affiliated_organisation.Name}}' requires approval"
}

func (e *AffiliatedOrganisationAdded) ApprovedTemplate() string {
	return "Affiliation of organisation '{{affiliated_organisation.Name}}' approved"
}

func (e *AffiliatedOrganisationAdded) RejectedTemplate() string {
	return "Affiliation of organisation '{{affiliated_organisation.Name}}' rejected"
}

func (e *AffiliatedOrganisationAdded) NotificationVariables() map[string]string {
	return map[string]string{
		"event.AffiliatedOrganisationID": e.AffiliatedOrganisationID.String(),
	}
}

type AffiliatedOrganisationAddedInput struct {
	AffiliatedOrganisationID uuid.UUID `json:"affiliated_organisation_id"`
}

func DecideAffiliatedOrganisationAdded(
	projectID uuid.UUID,
	actor uuid.UUID,
	cur *entities.Project,
	in AffiliatedOrganisationAddedInput,
	status Status,
) (Event, error) {
	if projectID == uuid.Nil {
		return nil, errors.New("project id is required")
	}
	if in.AffiliatedOrganisationID == uuid.Nil {
		return nil, errors.New("affiliated_organisation_id is required")
	}
	if cur == nil {
		return nil, errors.New("current project is required")
	}
	for _, x := range cur.AffiliatedOrganisationIDs {
		if x == in.AffiliatedOrganisationID {
			return nil, fmt.Errorf("affiliatedorganisation %s already exists", in.AffiliatedOrganisationID)
		}
	}
	base := NewBase(projectID, actor, status)
	base.FriendlyNameStr = AffiliatedOrganisationAddedMeta.FriendlyName

	return &AffiliatedOrganisationAdded{
		Base:                     base,
		AffiliatedOrganisationID: in.AffiliatedOrganisationID,
	}, nil
}

var AffiliatedOrganisationAddedMeta = EventMeta{
	Type:         AffiliatedOrganisationAddedType,
	FriendlyName: "Affiliated Organisation Addition",
}

// --- AffiliatedOrganisationRemoved ---

type AffiliatedOrganisationRemoved struct {
	Base
	AffiliatedOrganisationID uuid.UUID `json:"affiliated_organisation_id"`
}

func (AffiliatedOrganisationRemoved) isEvent()     {}
func (AffiliatedOrganisationRemoved) Type() string { return AffiliatedOrganisationRemovedType }
func (e AffiliatedOrganisationRemoved) String() string {
	return fmt.Sprintf("AffiliatedOrganisation removed: %s", e.AffiliatedOrganisationID)
}

func (e *AffiliatedOrganisationRemoved) Apply(project *entities.Project) {
	for i, x := range project.AffiliatedOrganisationIDs {
		if x == e.AffiliatedOrganisationID {
			project.AffiliatedOrganisationIDs = append(project.AffiliatedOrganisationIDs[:i], project.AffiliatedOrganisationIDs[i+1:]...)
			return
		}
	}
}

func (e *AffiliatedOrganisationRemoved) RelatedIDs() RelatedIDs {
	return RelatedIDs{AffiliatedOrganisationID: &e.AffiliatedOrganisationID}
}

func (e *AffiliatedOrganisationRemoved) NotificationMessage() string {
	return "A affiliatedorganisation has been removed from the project."
}

func (e *AffiliatedOrganisationRemoved) NotificationTemplate() string {
	return "Organisation '{{affiliated_organisation.Name}}' was removed from project '{{project.Title}}'"
}

func (e *AffiliatedOrganisationRemoved) ApprovalRequestTemplate() string {
	return "Request to remove organisation '{{affiliated_organisation.Name}}' requires approval"
}

func (e *AffiliatedOrganisationRemoved) ApprovedTemplate() string {
	return "Removal of organisation '{{affiliated_organisation.Name}}' approved"
}

func (e *AffiliatedOrganisationRemoved) RejectedTemplate() string {
	return "Removal of organisation '{{affiliated_organisation.Name}}' rejected"
}

func (e *AffiliatedOrganisationRemoved) NotificationVariables() map[string]string {
	return map[string]string{
		"event.AffiliatedOrganisationID": e.AffiliatedOrganisationID.String(),
	}
}

type AffiliatedOrganisationRemovedInput struct {
	AffiliatedOrganisationID uuid.UUID `json:"affiliated_organisation_id"`
}

func DecideAffiliatedOrganisationRemoved(
	projectID uuid.UUID,
	actor uuid.UUID,
	cur *entities.Project,
	in AffiliatedOrganisationRemovedInput,
	status Status,
) (Event, error) {
	if projectID == uuid.Nil {
		return nil, errors.New("project id is required")
	}
	if in.AffiliatedOrganisationID == uuid.Nil {
		return nil, errors.New("affiliated_organisation_id is required")
	}
	if cur == nil {
		return nil, errors.New("current project is required")
	}
	found := false
	for _, x := range cur.AffiliatedOrganisationIDs {
		if x == in.AffiliatedOrganisationID {
			found = true
			break
		}
	}
	if !found {
		return nil, fmt.Errorf("affiliatedorganisation %s not found", in.AffiliatedOrganisationID)
	}
	base := NewBase(projectID, actor, status)
	base.FriendlyNameStr = AffiliatedOrganisationRemovedMeta.FriendlyName

	return &AffiliatedOrganisationRemoved{
		Base:                     base,
		AffiliatedOrganisationID: in.AffiliatedOrganisationID,
	}, nil
}

var AffiliatedOrganisationRemovedMeta = EventMeta{
	Type:         AffiliatedOrganisationRemovedType,
	FriendlyName: "Affiliated Organisation Removal",
}

func init() {
	RegisterMeta(ProductAddedMeta, func() Event {
		return &ProductAdded{Base: Base{FriendlyNameStr: ProductAddedMeta.FriendlyName}}
	})
	RegisterDecider[ProductAddedInput](ProductAddedType,
		func(ctx context.Context, projectID uuid.UUID, actor uuid.UUID, cur *entities.Project, in ProductAddedInput, status Status) (Event, error) {
			return DecideProductAdded(projectID, actor, cur, in, status)
		})
	RegisterInputType(ProductAddedType, ProductAddedInput{})

	RegisterMeta(ProductRemovedMeta, func() Event {
		return &ProductRemoved{Base: Base{FriendlyNameStr: ProductRemovedMeta.FriendlyName}}
	})
	RegisterDecider[ProductRemovedInput](ProductRemovedType,
		func(ctx context.Context, projectID uuid.UUID, actor uuid.UUID, cur *entities.Project, in ProductRemovedInput, status Status) (Event, error) {
			return DecideProductRemoved(projectID, actor, cur, in, status)
		})
	RegisterInputType(ProductRemovedType, ProductRemovedInput{})
	RegisterMeta(BudgetLineItemAddedMeta, func() Event {
		return &BudgetLineItemAdded{Base: Base{FriendlyNameStr: BudgetLineItemAddedMeta.FriendlyName}}
	})
	RegisterDecider[BudgetLineItemAddedInput](BudgetLineItemAddedType,
		func(ctx context.Context, projectID uuid.UUID, actor uuid.UUID, cur *entities.Project, in BudgetLineItemAddedInput, status Status) (Event, error) {
			return DecideBudgetLineItemAdded(projectID, actor, cur, in, status)
		})
	RegisterInputType(BudgetLineItemAddedType, BudgetLineItemAddedInput{})

	RegisterMeta(BudgetLineItemRemovedMeta, func() Event {
		return &BudgetLineItemRemoved{Base: Base{FriendlyNameStr: BudgetLineItemRemovedMeta.FriendlyName}}
	})
	RegisterDecider[BudgetLineItemRemovedInput](BudgetLineItemRemovedType,
		func(ctx context.Context, projectID uuid.UUID, actor uuid.UUID, cur *entities.Project, in BudgetLineItemRemovedInput, status Status) (Event, error) {
			return DecideBudgetLineItemRemoved(projectID, actor, cur, in, status)
		})
	RegisterInputType(BudgetLineItemRemovedType, BudgetLineItemRemovedInput{})
	RegisterMeta(AffiliatedOrganisationAddedMeta, func() Event {
		return &AffiliatedOrganisationAdded{Base: Base{FriendlyNameStr: AffiliatedOrganisationAddedMeta.FriendlyName}}
	})
	RegisterDecider[AffiliatedOrganisationAddedInput](AffiliatedOrganisationAddedType,
		func(ctx context.Context, projectID uuid.UUID, actor uuid.UUID, cur *entities.Project, in AffiliatedOrganisationAddedInput, status Status) (Event, error) {
			return DecideAffiliatedOrganisationAdded(projectID, actor, cur, in, status)
		})
	RegisterInputType(AffiliatedOrganisationAddedType, AffiliatedOrganisationAddedInput{})

	RegisterMeta(AffiliatedOrganisationRemovedMeta, func() Event {
		return &AffiliatedOrganisationRemoved{Base: Base{FriendlyNameStr: AffiliatedOrganisationRemovedMeta.FriendlyName}}
	})
	RegisterDecider[AffiliatedOrganisationRemovedInput](AffiliatedOrganisationRemovedType,
		func(ctx context.Context, projectID uuid.UUID, actor uuid.UUID, cur *entities.Project, in AffiliatedOrganisationRemovedInput, status Status) (Event, error) {
			return DecideAffiliatedOrganisationRemoved(projectID, actor, cur, in, status)
		})
	RegisterInputType(AffiliatedOrganisationRemovedType, AffiliatedOrganisationRemovedInput{})
}
